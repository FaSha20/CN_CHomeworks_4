## پیاده سازی و تحلیل الگوریتم های کنترل ازدحام 

در این تمرین سه الگوریتم ازدحام را برای TCP پیاده سازی کردیم :

# Reno and New Reno

این دو الگوریتم مراحل پیاده سازی یکسان دارند بنابراین توابع استفاده شده در پباده سازی آن ها مشابه است . 
در ابتدا نیاز به یک کلاس برای پیاده سازی TCP connection داریم که طبق توضیحات داده شده در صورت سوال به صورت زیر است :


[![image](https://www.linkpicture.com/q/TCP_conection.png)](https://www.linkpicture.com/view.php?img=LPic648c9e4b2201f737222516)

پس از آن متد onPacketLoss را تعریف میکنیم . 
این متد دو بخش برای Reno
و New Reno دارد . 
در بخش Reno به ازای 
هر packet loss در یک پنجره سایز پنجره نصف میشود 
در حالی که یک بار کاهش سایز کافی بوده است . 
الگوریتم New Reno این مشکل 
را با چندین packet loss ندارد . 
یک متد مهم دیگر در این پیاده سازی onRTTUpdate است :

[![image](https://www.linkpicture.com/q/Screen-Shot-2023-06-16-at-3.29.39-PM.png)](https://www.linkpicture.com/view.php?img=LPic648c9e4b2201f737222516)



نتایج new reno :

[![image](https://www.linkpicture.com/q/new_7.png)](https://www.linkpicture.com/view.php?img=LPic648cb0e1cc43c383246888)


در این تصویر میبینیم که packet loss اتفاق افتاده است .
نتایج reno :


[![image](https://www.linkpicture.com/q/2_5.png)](https://www.linkpicture.com/view.php?img=LPic648cb098c5eb21618395877)

[![image](https://www.linkpicture.com/q/1_4.png)](https://www.linkpicture.com/view.php?img=LPic648cb098c5eb21618395877)

# BBR

این الگوریتم با دو الگوریتم بالا تفاوت دارد . 
در BBR اندازه پنجره برابر
حاصل ضرب پهنای باند گلوگاه و RTT است . 
بخش اصلی آن در تابع handleACK پیاده سازی شده است که به صورت زیر است :



[![image](https://www.linkpicture.com/q/bbr_1.png)](https://www.linkpicture.com/view.php?img=LPic648c9e4b2201f737222516)

تصویر نتایج آن به این صورت است :

[![image](https://www.linkpicture.com/q/bbr-result.png)](https://www.linkpicture.com/view.php?img=LPic648c9f7d822d5939832771)

# تعریف تابع اصلی

این تابع یک محیط شبکه را شبیه سازی میکند . 
در آن یک TCP Connection میسازیم و 
بیست packet میسازیم و با توجه 
به شماره بسته و نوع الگوریتم آن برایش تصمیم میگیریم که کدام توابع را اجرا کنیم . 
تابع آن به صورت زیر است : 


[![image](https://www.linkpicture.com/q/main_3.png)](https://www.linkpicture.com/view.php?img=LPic648c9e4b2201f737222516)




## سوالات

# تفاوت کنترل ازدحام و کنترل جمعیت

کنترل ازدحام و کنترل جریان هردو از متدهای کنترل ترافیک در شبکه هستند. کنترل جریان مکانیزمی است که در ارتباط میان دو ایستگاه فرستنده و گیرنده، تضمین میکند که نرخ ارسال فرستنده با نرخ دریافت گیرنده متناسب باشد. ایستگاه های مختلف یک شبکه در ظرفیت و سرعت باهم تفاوت دارند و اگر فرستنده با نرخ بالایی پکتها را برای یک گیرنده کند ارسال کند، گیرنده اصطلاحا overwhelmed میشود
و دریافت به درستی اتفاق نمیافتد. پس پروتکلهای متد کنترل جریان، جریان داده میان فرستنده و گیرنده را بر اساس ظرفیتهایشان تنظیم میکنند.

ازدحام زمانی رخ میدهد که شبکه بسیار بیش از ظرفیتش پکت دریافت کند. وقتی یک نود یا لینک بیش از میزان ظرفیتش داده دریافت کند، موجب ایجاد مشکلاتی مانند queuing delay، از دست رفتن یا گم شدن پکتها و پایین آمدن کیفیت سرویسدهی شبکه میشود. 
 پروتکلهای کنترل ازدحام تلاش میکنند ضمن استفاده مناسب و عدم هدررفت از منابع،  چنین شرایط بحرانی در شبکه پیش نیاید و اگر هم رخ داد، به طور مناسبی برطرف شود.
 به طور کلی از تفاوتهای کنترل ازدحام و کنترل جریان میتوان به موارد زیر اشاره کرد:

-لایه های data link
و transport کنترل جریان را هندل میکنند.
 اما کنترل ازدحام در لایه های network
 و transport اتفاق میفتد. 

-کنترل جریان از overwhelm شدن گیرنده جلوگیری میکند اما کنترل ازدحام از ایجاد ازدحام در شبکه جلوگیری میکند. 

-در کنترل جریان، فرستنده مسئول ترافیک است اما در کنترل ازدحام، لایه انتقال مسئول کنترل ترافیک است. 

-در کنترل جریان، کنترل ترافیک با کاهش سرعت فرستنده انجام میشود اما در کنترل ازدحام، کاهش سرعت لایه انتقال موجب پیشگیری از رخ دادن ازدحام میشود. 


# توضیحات الگوریتم ها و معرفی دو الگوریتم کنترل ازدحام دیگر

# TAHOE

اولین نسخه tcp بود که در خودش الگوریتم کنترل ازدحام داشت.
Tcp tahoe
شامل slow start
و AIMD
و fast retransmission بود. 

فاز slow start:
تا زمانی که cwnd
به سایز ssthreash برسد در این فاز هستیم.
در هر RTT
اندازه cwnd دو برابر میشود تا جایی
که به ssthresh برسد.
اندازه ssthresh در ابتدا بینهایت درنظر گرفته میشود لذا
اولین بار، این timeout است که ما را از این فاز خارج میکند.
پس از timeout، این مقدار
به نصف cwnd در آن زمان ست میشود
 وقتی cwnd
 به ssthresh میرسد،
 slow start به پایان میرسد و وارد
  فاز AIMD میشویم. 

فاز AIMD:
در additive increase در
هر RTT 
اندازه cwnd 1 واحد افزایش می یابد
 و در multiplicative decrease،
 ssthresh به
 نصف cwnd کاهش می یابد
 و cwnd به مقدار اولیه اش بازمیگردد

 فاز fast retransmit:
 این فاز برای زمانی است که پکتی از دست رفته است. پس از دریافت 3 سیگنال ack تکراری،
 متوجه میشویم که پکت گم شده است و باید مجددا ارسال شود. 
 زمانی که یک packet loss شناسایی
  شود، cwnd به مقدار اولیه اش ریست میشود. 


[![image](https://www.linkpicture.com/q/tah.png)](https://www.linkpicture.com/view.php?img=LPic648ca0c01cd49619705497)



# Reno 

این الگوریتم بر اساس tcp tahoe طراحی شده است و علاوه بر فازهای بیان شده
در بالا، fast recovery نیز دارد و برای این کار
 هم از الگوریتم RTO 
 و هم از fast retransmit استفاده میکند.
 زمانی که پس از دریافت3 ack
 تکراری packet lost شناسایی
شود، cwnd به میزان نصف خودش برمیگردد نه مقدار اولیه.
 چون زمانی که سه تا ack تکراری دریافت شود، به این معناست که شبکه دارد به خوبی عمل میکند چون پکت ها دارند به گیرنده میرسند.
  پس cwnd به نصف خودش برمیگردد
  که از حالت congested خارج شود.
اما زمانی که packet loss از طریق
روش RTO شناسایی
شود، cwnd به میزان اولیه اش برمیگردد.
چرا که زمانی که تایمر RTO منقضی شود، یعنی شبکه بسیار دچار ازدحام شده است و شبکه در وضعیت وخیمی قرار دارد. 
لذا cwnd را ریست میکنیم.
 در هر دو حالت مقدار ssthresh به
 اندازه نصف cwnd پیش از کاهش میشود. 

مجدد با AIMDشروع میکنیم.
در reno
پس از fast recovery از
مرحله slow start چشم پوشی میشو
و وارد AIMD میشویم.
 در حالی که در tahoe پس
  از fast retransmit
  وارد slow start میشدیم.


[![image](https://www.linkpicture.com/q/reni.png)](https://www.linkpicture.com/view.php?img=LPic648ca0c01cd49619705497)



این الگوریتم برای زمانی که تعداد packet loss ها محدود است
و در هر پنجره نهایتا یک packet loss اتفاق میفتد، بسیار خوب عمل میکند.
اما زمانی که چندین packet loss در یک پنجره داشته باشیم، خوب عمل نمیکند
و تقریبا مانند tahoe میشود.
این مکانیزم تنها یک packe loss را شناسایی میکند
و زمانی که 3 ack یکسان را دریافت کرد  و اولین پکت گمشده شناسایی
شد، ack تکراری پکت گمشده دوم پس
از ack رسیدن
پکت retransmit شده ی اول بعد
از گذشت یک RTT میرسد.
 لذا به ازای هر packet loss در یک پنجره، سایز پنجره نصف میشود در حالی که یک بار کاهش اندازه پنجره کافی بود. 
 همچنین اگر اندازه cwnd هنگام
 رخ دادن packet loss بسیار کوچک باشد،
 آنگاه نمیتوانیم تعداد کافی ack تکراری دریافت کنیم
 که وارد fast retransmission شویم و باید به
 اندازه یک timeout کامل صبر کنیم.
  لذا نمیتوان چندین packet loss را شناسایی کرد. 


# New Reno

این الگوریتم مبتنی بر reno است و
مشکل شناسایی چندین packet loss در یک پنجره
که در reno با مشکل مواجه میشد، در آن برطرف شده است.
 ایده اصلی این الگوریتم است است که فرستنده بداند برای تمامی packet loss هایی که
 در یک cwnd رخ میدهند، تنها یک بار اندازه پنجره را کاهش بدهد.
  برای این کار از partial ack ها استفاده میکنیم.
  در reno، زمانی
که فرستنده ack مربوط به دریافت
پکت گمشده retransmit شده را دریافت میکند،
 آن را یک ack جدید حساب میکند
 و از fast recovery
 به AIMD میرود و سایز پنجره را کاهش میدهد.
  لذا اگر در همان پنجره packet loss دیگری شناسایی شود، مجدد این پروسه را تکرار میکند و پنجره را کوچک میکند.
اما در new reno فرستنده پس از
دریافت ack چک میکند که آیا این سیگنال جدید است یا خیر.
به این معنا که آیا تمامی پکتهای آن cwnd نوسط
گیرنده ack شده اند یا خیر.
اگر تمامی پکتها توسط گیرنده ack شده باشند
 فرستنده ack جدید را
 به عنوان ack جدید ثبت میکند
  و به AIMD میرود و سایز پنجره را گوچک میکند.
 اما اگر غیر از این باشد، partial ack ثبت میکند و
 لذا پنجره را کوچک نمیکند و از فاز fast recovery بیرون نمی آید. 

مشکلی که این الگوریتم دارد این است که برای شناسایی و detect
هر packet loss به
یک RTT احتیاج دارد. یعنی ابتدا گمشدن یک پکت را متوجه میشویم، مجدد ارسال
میکنیم، ack مربوط به آن را دریافت میکنیم و سپس متوجه گم شدن پکت دیگر همان پنجره میشویم. 



# SACK

این روش نیز مبتنی بر الگوریتم reno است
که از selective acks استفاده میکند که برای حل مشکل شناسایی و بازارسال بیش از یک پکت گمشده 
در هر RTT که هم
در reno و
هم new reno وجود دارد، طراحی شده است.
ایده اصلی این الگوریتم این است که بخش ها یا segmentها به صورت
تجمعی ack نشوند بلکه به صورت
انتخابی ack شوند.
 لذا هر ack بلوکی دارد که مشخص میکند کدام
 بخشها ack  شده و کدام بخشها هنوز منتظر هستند.
  زمانی که فرستنده وارد استیت fast recovery میشود،
 یک متغیر pipe دارد که تخمین میزند چه مقدار داده هنوز در شبکه است
 که ack نشده است 
  و همچنین اندازه cwnd را به نصف کاهش میدهد.
هر زمان یک ack دریافت کند،
متغیر pipe را یک واحد کاهش میدهد و هر زمان یک بخش را مجددا ارسال کند، یک واحد افزایش میدهد.
 هر زمان اندازه pipe  کوچکتر 
از cwnd شود، فرستنده چک میکند که کدام بخش ها دریافت نشده اند و مجدد آنها را ارسال میکند.
 اگر چنین بخشی وجود نداشت، پکت جدید را ارسال میکند. لذا در این روش بیش از یک segment گمشده 
 در یک RTT  ارسال میشود.

# Vegas

 این الگوریتم نسبت به الگوریتمهایی که پیشتر بررسی شد، مشی متفاوتی دارد.
 در الگوریتمهای مبتنی بر TAHOE، از پدیده
 از دست رفتن پکت ها یا packet loss برای کشف وجود ازدحام در شبکه استفاده میشد.
  اما در این الگوریتم از تفاوت میان throughput واقعی
و throughput مورد انتظار، متوجه ازدحام میشویم و
اندازه cwnd را بر اساس این تفاوت تنظیم میکنیم.
لذا زمان تلف شده برای timeout وجود ندارد و نیز برای
کشف packet loss به
 تعدادی ack تکراری نیاز نداریم.
 این الگوریتم از packet loss به عنوان
 نشانه congestion استفاده نمیکند.
 بلکه congestion را پیش از از دست رفتن پکتها شناسایی میکند. هرچند همچنان
در صورت وقوع packet loss از مکانیزمهای مشابه سایر الگوریتمها استفاده میکند.

در tcp vegas فرستنده همواره درحال
مانیتور کردن RTT پکتهاست.
 اگر مقدار این RTT بسیار بزرگ شود، به معنای وجود ازدحام در شبکه است.
 لذا فرستنده cwnd را کاهش میدهد که نرخ ارسال داده را کاهش دهد.

 Vegas زمانی که
هر segment ارسال میشود را ثبت میکند و با دنبال کردن
زمان برگشت ack برای هر پکت،
تخمینی از میزان RTT دارد.
زمانی که یک ack تکراری دریافت میشود،
چک میکند که آیا current time – segment transmission time > RTT است یا خیر.
اگر بزرگتر باشد، فورا segment را مجددا ارسال میکند و منتظر
دریافت 3 ack تکراری
یا timeput نمی ماند
لذا این مشکل که زمانی که اندازه پنجره بسیار کوچک باشد، نمیتواند تعداد کافی ack دریافت کند و لذا پکتهای گمشده را شناسایی نمیکند، از بین میرود. 

همچنین برای شناسایی چندین packet loss در یک پنجره، زمانی
که یک ack غیر تکراری دریافت میشود،
اگر این سیگنال اولین یا دومین ack پس از یک ack جدید باشد،
مجدد مقادیر timeout را چک میکند و اگر زمان از لحظه
ارسال آن segment بیشتر
از مقدار timeout باشد،
 بدون صبر برای ack تکراری، retransmit میکند.
  همچنین تنها زمانی سایز cwnd را کاهش
میدهد که retransmitted segment پس از
آخرین کاهش cwnd ارسال شده باشد.
لذا مشکل چندین کاهش cwnd متوالی
به ازای چندین packet loss یک
پنجره که reno با آن مواجه بود، در این الگوریتم وجود ندارد.

برای دوری از ازدحام
vegas با
مقایسه rate واقعی
و rate مورد انتظار،
اندازه cwnd را تنظیم میکند
و صرفا از packet loss به عنوان نشانه ازدحام استفاده نمیکند.
زمانی که نرخ واقعی خیلی با نرخ مورد انتظار فاصله داشته باشد، transmission را افزایش میدهد که از پهنای باند در دسترس استفاده کند.
زمانی که نرخ واقعی خیلی به نرخ مورد انتظار نزدیک شود، transmission را کاهش میدهد که از فوق اشباع شدن پهنای باند جلوگیری کند. لذا نسبت به سایر الگوریتمهای بررسی شده، بهتر از پهنای باند و منابع استفاده میکند. 


با توجه به نکات گفته شده، vegas از
tahoe و
reno و 
new reno و
 sack بهتر عمل میکند.
برخی از این دلایل در ادامه ذکر شده اند: 

-باز بیش از نیمی از timeout های
 درشت دانه reno جلوگیری میشود.
 چرا که vegas پیش
 از timeout، بیش از یک پکت گمشده را شناسایی و باز ارسال میکند. 


-نیازی ندارد که همیشه منتظر 3 ack تکراری بماند
 و میتواند سریعتر retransmit کند.


 -اندازه cwnd را خیلی کاهش نمیدهد و دچار کاهش های متوالی نمیشود. 

 -از پهنای باند بهتر و با بازده بالاتر استفاده میکند.


# BRR

الگوریتم BBR
یا Bottleneck Bandwidth and Round-trip propagation time نیز
مشابه vegas،
از packet loss به عنوان سیگنالی برای کاهش نرخ ارسال 
 استفاده نمیکند و از latency استفاده میکند.
با استفاده از این روش، throuput بهتر
و latency پایینتری خواهیم داشت
در BBR اندازه پنجره برابر حاصل ضرب پهنای باند گلوگاه و 
RTT است




# مقایسه ۳ الگوریتم 

در اینجا یک یک تابع نوشته و عملکرد آن ها را با هم مقایسه کردیم که تابع آن به صورت زیر است :


[![image](https://www.linkpicture.com/q/compare.png)](https://www.linkpicture.com/view.php?img=LPic648c9f7d822d5939832771)


نتایج آن  به صورت زیر است :



[![image](https://www.linkpicture.com/q/compare-result.png)](https://www.linkpicture.com/view.php?img=LPic648c9f7d822d5939832771)


نتایج نشان میدهد که new reno
از reno بهتر است 
و bbr از هر دو بهتر است
زیرا packet loss کمتری وجود دارد
